# SPDX-License-Identifier: Apache-2.0

# Invoke this makefile one of three ways:
# With no target           : runs default target that expects the host to contain the build tools
# With docker target       : runs Make inside docker or podman with default target
# With docker-cache target : like docker target, but with a second volume mount for a persistent go module cache dir of .cache
#
# If docker does not exist, podman will be used instead

# If docker and podman both exist:
# - by default, docker will be used
# - passing use_docker=0 will use podman

# If neither docker nor podman exist:
# - an error occurs if you call the docker targets
# - no error occurs if you do not call the docker targets

# Passing count=N for some integer N will run the unit tests N times

# Passing run=T for some pattern T will run the unit tests whose names match the pattern

#### User variables, it is expected these values can be overriden on make command line

# Count of how many times to run the unit tests, default is once.
count      := 1

# Pattern for which test(s) to run, default is all of them (no pattern)
run        :=

#### Variables required for Makefile

# The docker image name, in case we use docker
DOCKER_IMAGE_NAME    := golang

# Path to docker, if we have it
DOCKER_PATH          := $(shell which docker 2> /dev/null || :)

# The podman image name for latest golang, in case we use podman
PODMAN_IMAGE_NAME    := docker.io/library/golang

# Path to podman, if we have it
PODMAN_PATH          := $(shell which podman 2> /dev/null || :)

# The absolute path to this Makefile
THIS_MAKEFILE_PATH   := $(abspath $(lastword $(MAKEFILE_LIST)))

# The absolute dir containing this Makefile
THIS_MAKEFILE_DIR    := $(patsubst %/,%,$(dir $(THIS_MAKEFILE_PATH)))

# The absolute dir for caching go artifacts across docker/podman builds
GO_CACHE_ROOT        := $(THIS_MAKEFILE_DIR)/.cache

# The absolute dir for caching go package dependencies pulled in by "go mod tidy"
GO_CACHE_PKG         := $(GO_CACHE_ROOT)/pkg

# The absolute dir for caching go build artifacts generated by "go build ./..."
GO_CACHE_BUILD       := $(GO_CACHE_ROOT)/build

### Targets

# Make using host packages - the default way of building (host, docker, podman)
.PHONY: all
all: vars tidy compile lint format test

# Make using docker - the docker image uses all target (host)
.PHONY: docker
docker: docker-check-image
	docker run --rm -it -v $(THIS_MAKEFILE_DIR):/workdir $(DOCKER_IMAGE_NAME) make count=$(count) run=$(run) -C /workdir

# Make using docker - as above, but with a additional volume mounts for persistent go module and go build caches (host)
.PHONY: docker-cache
docker-cache: docker-check-image $(GO_CACHE_PKG) $(GO_CACHE_BUILD)
	docker run --rm -it -v $(GO_CACHE_PKG):/go/pkg -v $(GO_CACHE_BUILD):/root/.cache -v $(THIS_MAKEFILE_DIR):/workdir $(DOCKER_IMAGE_NAME) make uid="`id -u`" gid="`id -g`" count=$(count) run=$(run) -C /workdir

# Check if the required docker image has already been pulled, and pull it if not (host)
.PHONY: docker-check-image
docker-check-image:
	[ -n "$(DOCKER_PATH)" ] || { echo "docker is not in the path"; exit 1; }; \
	[ "`docker images --format "{{.Repository}}" --filter "reference=$(DOCKER_IMAGE_NAME)" | wc -l`" -eq 1 ] \
	|| docker pull $(DOCKER_IMAGE_NAME)

# Make using podman - the podman image uses all target (host)
.PHONY: podman
podman: podman-check-image
	podman run -u root --rm -it -v $(THIS_MAKEFILE_DIR):/workdir $(PODMAN_IMAGE_NAME) make count=$(count) run=$(run) -C /workdir

# Make using podman - as above, but with a additional volume mounts for persistent go module and go build caches (host)
.PHONY: podman-cache
podman-cache: podman-check-image $(GO_CACHE_PKG) $(GO_CACHE_BUILD)
	podman run -u root --rm -it -v $(GO_CACHE_PKG):/go/pkg/mod -v $(GO_CACHE_BUILD):/root/.cache -v $(THIS_MAKEFILE_DIR):/workdir $(PODMAN_IMAGE_NAME) make count=$(count) run=$(run) -C /workdir

# Check if the required podman image has already been pulled, and pull it if not (host)
.PHONY: podman-check-image
podman-check-image:
	[ -n "$(PODMAN_PATH)" ] || { echo "podman is not in the path"; exit 1; }; \
	[ "`podman images --format "{{.Repository}}" --filter "reference=$(PODMAN_IMAGE_NAME)" | wc -l`" -eq 1 ] \
	|| podman pull $(PODMAN_IMAGE_NAME)

# Create directories needed for go module and go build caches (host)
$(GO_CACHE_PKG) $(GO_CACHE_BUILD):
	mkdir -p $@

# Download any missing go packages, update go.sum (host, docker, podman)
.PHONY: tidy
tidy:
	go mod tidy
	[ -z "$(uid)" ] || chown -R $(uid):$(gid) /go/pkg/mod # Only for docker-cache
	[ \! -d /go/pkg/mod ] || chmod -R u+w /go/pkg/mod 2> /dev/null || : # Only for docker-cache and podman-cache

# Compile go code (host, docker, podman)
.PHONY: compile
compile:
	go build ./...
	[ -z "$(uid)" ] || chown -R $(uid):$(gid) /root/.cache # Only for docker-cache
	[ \! -d /root/.cache ] || chmod -R u+w /root/.cache 2> /dev/null || : # Only for docker-cache and podman-cache

# Lint go code (host, docker, podman)
.PHONY: lint
lint:
	go vet ./...

# Format go code (host, docker, podman)
.PHONY: format
format:
	for pkg in `go list -f '{{.Dir}}' ./...`; do gofmt -s -w $${pkg}; done

# Test go code (host, docker, podman)
# May pass count=N to run tests n times
.PHONY: test
test:
	testOpt="-count=$${count:-1}"; \
	[ -n "$(run)" ] && testOpt="$$testOpt -run $(run)"; \
	go test -v $$testOpt ./...

.PHONY: vars (host, docker, podman)
.SILENT: vars
vars:
	printf "uid =\n    $(uid)\n"
	printf "gid =\n    $(gid)\n"
	printf "count =\n    $(count)\n"
	printf "run =\n    $(run)\n"
	printf "DOCKER_IMAGE_NAME =\n    $(DOCKER_IMAGE_NAME)\n"
	printf "DOCKER_PATH =\n    $(DOCKER_PATH)\n"
	printf "PODMAN_IMAGE_NAME =\n    $(PODMAN_IMAGE_NAME)\n"
	printf "PODMAN_PATH =\n    $(PODMAN_PATH)\n"
	printf "THIS_MAKEFILE_PATH =\n    $(THIS_MAKEFILE_PATH)\n"
	printf "THIS_MAKEFILE_DIR =\n    $(THIS_MAKEFILE_DIR)\n"
	printf "GO_CACHE_ROOT =\n    $(GO_CACHE_ROOT)\n"
	printf "GO_CACHE_PKG =\n    $(GO_CACHE_PKG)\n"
	printf "GO_CACHE_BUILD \\n    $(GO_CACHE_BUILD)\n"
