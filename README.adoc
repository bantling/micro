// SPDX-License-Identifier: Apache-2.0
:doctype:article

= Micro

Micro is a small library of useful stuff for small projects, particularly (but not limited to) REST/database projects.

== Packages

* constraint
** defines generic type constraints, some are similar to golang.org/x/exp/constraints
* conv
** converts between numeric types, panicking if any loss of precision would occur
* funcs
** slices:
*** access elements safely
*** flatten multiple dimensions into one
*** reverse elements
*** sort elements
** maps: access keys safely
** filter - func(T) bool:
*** compose with and, or, not
*** generate filters for comparisons (<, <=, ==, >=, >)
*** generate filters for is negative, is non-negative, is positive, is nil, is non nil
** compose any number of funcs that accept and receive same type
** compose up to 10 funcs that accept and return different types
** ternary - take a bool, true value or supplier, false value or supplier, and return true or false value
** min/max
** nil handling
** supplier generators
** generate a func that ignores result of another func
** TryTo is a replacement for hard to write idiomatic go code that acts like a Java try/catch/finally block:
   Accepts a func for a try block, a func for a catch block (only invoked if try block panics), and any number of
   closer funcs that close resources regardless of whether the try func panics.
* iter
** defines Iter type that can iterate anything
** based on iterating funcs, a func of no args that returns (value, bool), where the value is only relevant if the bool
   is true
** A number of constructors are provided for hard-coded values, slices, maps, io.reader, concat multiple iters
** Next, value, unread, and Must funcs to retrieve values
** Provides streaming functionality (similar to that of Java 8 streams).
    Most functions accept ands return an Iter, providing some kind of transform.
*** funcs for first, map, filter, reduce, expand, skip, limit, peek, generate infinite series, all match, any match,
   none match, count, distinct, duplicate, reverse, sort, and parallel
*** control over how and when parallel execution occurs, default algorithm provided
* json
** Value type that describes any kind of JSON value
** Convert between go types to Value and vice-versa (eg, map[string]any -> Value of type Object -> map[string]any)
** default numeric type is NumberString, but custom conversion functions can be used for some other numeric type
* util
** Provides ErrorReader to return a specified error after reading a specified set of bytes; useful for unit tests.

== Dependency Graph

A dependency graph can be generated anytime by running "make depgraph", which produces a file called "depgraph.svg" in
this directory, which can be viewed by a web browser, and is linked to by this document.

link:depgraph.svg[Dependency Graph]

== TODO

* Auto convert each JSON object into Go structs and vice-versa
* Auto write JSON objects to an SQL table that uses individual columns for each field
** Auto generate DDL for all free databases
** Struct tags to say if indexing is needed
** detect db by driver struct name
** Work with whole database or schema
** Different strategies for joins:
*** Embedded struct by default is flat table, with parent and child columns together (disambiguate name conflicts with struct tag)
    Can embedded struct have a tag to say make it separate or bridged?
*** Child struct by default is separate table, tag can make it flat or bridged
** requirements can be specd as a map[string db vendor]map[string object name]map[string property name]propdef, or by reading a struct.
   dbvendor is a string like mssql, postgresql, mysql, etc.
   propdef is a union of string coldef and map[string property name]propdef.
   coldef defines a column as just a single string, like 'varchar(max)' for mssql.
* Consider providing simplistic string based arbitrary precision that is not fast, but just does basic operations
* ETL operations
** JSON iter of PV pairs for objects, where P is path
** JSON look up a string path of key names and indexes, as in "addresses[0].city"
** Look at steps Pentaho and Talend provide as a rough guide
